# Import the necessary modules
import sys
import urllib.request
from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QLineEdit, QPushButton, QVBoxLayout, QProgressBar
from PyQt5.QtCore import QThread, pyqtSignal
from pytube import YouTube

# Define a custom thread class that handles the downloading process
class DownloadThread(QThread):
    # Define a signal that emits the progress percentage as an integer
    progress_signal = pyqtSignal(int)

    # Initialize the thread with the video url and the save path
    def __init__(self, url, save_path):
        super().__init__()
        self.url = url
        self.save_path = save_path

    # Define the main logic of the thread
    def run(self):
        try:
            # Create a YouTube object from the url
            yt = YouTube(self.url)
            # Get the first mp4 video stream with progressive download
            video = yt.streams.filter(file_extension="mp4", progressive=True).first()
            # Get the total size of the video in bytes
            total_bytes = video.filesize
            # Initialize a variable to store the downloaded bytes
            downloaded_bytes = 0

            # Open the video url as a response object
            with urllib.request.urlopen(video.url) as response:
                # Open the save path as a file object in write-binary mode
                with open(self.save_path, 'wb') as file:
                    # Define a chunk size of 1 KB
                    chunk_size = 1024
                    # Loop until the response is exhausted
                    while True:
                        # Read a chunk from the response
                        chunk = response.read(chunk_size)
                        # If the chunk is empty, break the loop
                        if not chunk:
                            break
                        # Write the chunk to the file
                        file.write(chunk)
                        # Update the downloaded bytes
                        downloaded_bytes += len(chunk)
                        # Calculate the progress percentage
                        progress = int((downloaded_bytes / total_bytes) * 100)
                        # Emit the progress signal
                        self.progress_signal.emit(progress)

        # Handle any exception that may occur
        except Exception as e:
            # Print the error message
            print(f"Error: {e}")

# Define a custom widget class that represents the main window of the application
class YouTubeDownloaderApp(QWidget):
    # Initialize the widget
    def __init__(self):
        super().__init__()

        # Initialize the download thread as a member variable
        self.download_thread = None

        # Set up the user interface
        self.initUI()

    # Define the user interface elements and layout
    def initUI(self):
        # Set the window title
        self.setWindowTitle('YouTube Downloader')
        # Set the window size and position
        self.setGeometry(300, 300, 400, 150)

        # Create a label for the url input
        self.url_label = QLabel('Enter YouTube Video URL:')
        # Create a line edit for the url input
        self.url_input = QLineEdit()
        # Create a button for the download action
        self.download_button = QPushButton('Download')
        # Connect the button click signal to the start download method
        self.download_button.clicked.connect(self.start_download)

        # Create a progress bar for the download progress
        self.progress_bar = QProgressBar()
        # Set the initial value of the progress bar to zero
        self.progress_bar.setValue(0)

        # Create a vertical box layout
        vbox = QVBoxLayout()
        # Add the widgets to the layout
        vbox.addWidget(self.url_label)
        vbox.addWidget(self.url_input)
        vbox.addWidget(self.download_button)
        vbox.addWidget(self.progress_bar)
        # Add some stretch space to the layout
        vbox.addStretch()

        # Set the layout of the widget
        self.setLayout(vbox)

    # Define the method that starts the download process
    def start_download(self):
        # If a thread is already running, don't start a new one
        if self.download_thread is not None and self.download_thread.isRunning():
            return

        # Get the url from the line edit
        url = self.url_input.text()
        # Define the save path for the video
        save_path = 'downloaded_video.mp4'

        # Create a new download thread with the url and the save path
        self.download_thread = DownloadThread(url, save_path)
        # Connect the thread progress signal to the update progress method
        self.download_thread.progress_signal.connect(self.update_progress)
        # Start the thread
        self.download_thread.start()

    # Define the method that updates the progress bar value
    def update_progress(self, progress):
        # Set the value of the progress bar to the progress percentage
        self.progress_bar.setValue(progress)

    # Define the method that handles the widget close event
    def closeEvent(self, event):
        # Ensure that the thread is stopped before the application exits
        if self.download_thread is not None and self.download_thread.isRunning():
            # Quit the thread
            self.download_thread.quit()
            # Wait for the thread to finish
            self.download_thread.wait()

# Define the main entry point of the program
if __name__ == '__main__':
    # Create a Qt application object
    app = QApplication(sys.argv)
    # Create a YouTubeDownloaderApp widget object
    window = YouTubeDownloaderApp()
    # Show the widget
    window.show()
    # Execute the application
    sys.exit(app.exec_())
The first line imports the sys module, which provides access to system-specific parameters and functions1.
The second line imports the urllib.request module, which provides an interface for opening URLs2.
The third line imports several classes from the PyQt5.QtWidgets module, which provides a set of user interface elements for creating GUI applications3.
The fourth line imports two classes from the PyQt5.QtCore module, which provides core non-GUI functionality4.
The fifth line imports the YouTube class from the pytube module, which is a library for downloading YouTube videos.
The seventh line defines a custom subclass of QThread, which is a class for creating and managing threads.
The eighth line defines a custom signal named progress_signal, which is an object that can emit values to other objects. In this case, the signal emits an integer value that represents the download progress percentage.
The tenth line defines the __init__ method of the DownloadThread class, which is a special method that is called when an instance of the class is created. The method takes two parameters: url and save_path, which are the video URL and the file path where the video will be saved. The method calls the __init__ method of the superclass (QThread) and assigns the parameters to the instance attributes (self.url and self.save_path).
The fifteenth line defines the run method of the DownloadThread class, which is a method that is executed when the thread is started. The method contains the main logic of the downloading process.
The sixteenth line uses a try block to handle any exception that may occur during the downloading process.
The seventeenth line creates a YouTube object from the self.url attribute, which represents the video URL.
The eighteenth line gets the first video stream that has the mp4 file extension and the progressive attribute, which means that the video and audio are in a single file. The video variable holds a reference to the stream object.
The nineteenth line gets the total size of the video in bytes by accessing the filesize attribute of the stream object. The total_bytes variable holds the value.
The twentieth line initializes a variable named downloaded_bytes to zero, which will store the amount of bytes that have been downloaded so far.
The twenty-second line uses a with statement to open the video URL as a response object, which is a context manager that automatically closes the connection when the block ends. The response variable holds a reference to the response object.
The twenty-third line uses another with statement to open the self.save_path attribute as a file object in write-binary mode, which is another context manager that automatically closes the file when the block ends. The file variable holds a reference to the file object.
The twenty-fourth line defines a variable named chunk_size and assigns it the value of 1024, which means 1 KB. This is the size of the chunks that will be read from the response and written to the file.
The twenty-fifth line uses a while loop to iterate until the response is exhausted.
The twenty-sixth line reads a chunk of chunk_size bytes from the response and assigns it to the chunk variable.
The twenty-seventh line uses an if statement to check if the chunk is empty, which means that there is no more data to read from the response. If so, the loop is broken by using the break statement.
The twenty-ninth line writes the chunk to the file.
The thirtieth line updates the downloaded_bytes variable by adding the length of the chunk to it.
The thirty-first line calculates the progress percentage by dividing the downloaded_bytes by the total_bytes and multiplying